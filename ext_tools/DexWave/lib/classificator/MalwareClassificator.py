import os
from datetime import datetime
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
# Perform operation on CPU to avoid loading of libraries for GPU (no training required)
os.environ['CUDA_VISIBLE_DEVICES'] = '-1'
import tensorflow as tf
from os import path
from sys import argv
from lib.classificator.Model import MCModel
import numpy as np
import logging

logging.getLogger("tensorflow").setLevel(logging.ERROR)
logging.getLogger("tensorflow").addHandler(logging.NullHandler(logging.ERROR))
        

class MalwareClassificator:
    def __init__(self, family_n, image_size, family_labels=None):
        self.family_n = family_n
        self.family_labels = family_labels
        self.image_size = image_size
        self.channels = 3 # Even if it is a GS image, they needs to be three
        self.weights_loaded = False
        self.model = MCModel(family_n, image_size, 3)
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.DEBUG)
        

    def load_weights(self, path="./weights_result"):
        if not os.path.exists('{}.index'.format(path)):
            raise FileNotFoundError('weights file {} does not exist or is unaccessible'.format(path))
        else:
            try:
                self.model.load_weights(path)
                self.model.compile(
                    optimizer=tf.keras.optimizers.Adam(),
                    loss=tf.keras.losses.CategoricalCrossentropy(),
                    metrics=['accuracy']
                )
            except Exception as ex:
                raise Exception('error during model loading: {}'.format(ex))
            self.weights_loaded = True 
    
    def predict(self, path):
        if self.weights_loaded:
            image_content = tf.io.read_file(path)
            image = tf.image.decode_image(image_content, channels=3)
            image = tf.image.resize(image, [self.image_size, self.image_size])
            image_array = np.array([image])
            return self.model.predict(image_array)
        else:
            raise Exception('model weights have not been loaded')

    def get_label_from_prediction(self, prediction):
        if not self.family_labels is None:
            index = np.argmax(prediction)
            return self.family_labels[index]
        else:
            raise Exception('family labels not set')